// Copyright IBM Corp. 2019. All Rights Reserved.
// Node module: @loopback/cli
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT

import chalk from 'chalk';
import latestVersion from 'latest-version';
import semver from 'semver';
import {format} from 'util';
import {LoopBackGenerator} from './types';

const cliPkg = require('../package.json');
const templateDeps = cliPkg.config.templateDependencies;

/**
 * Print @loopback/* versions
 * @param log - A function to log information
 */
export function printVersions(log = console.log) {
  const ver = cliPkg.version;
  log('@loopback/cli version: %s', ver);
  log('\n@loopback/* dependencies:');
  for (const d in templateDeps) {
    if (d.startsWith('@loopback/') && d !== '@loopback/cli') {
      log('  - %s: %s', d, templateDeps[d]);
    }
  }
}

/**
 * Check project dependencies against module versions from the cli template
 * @param generator - Yeoman generator instance
 */
export async function checkDependencies(generator: LoopBackGenerator) {
  const pkg = generator.fs.readJSON(generator.destinationPath('package.json'));
  generator.packageJson = pkg;

  if (!pkg) {
    if (generator.command === 'update') {
      printVersions(generator.log);
      await checkCliVersion(generator.log);
      return;
    }
    const err = new Error(
      'No package.json found in ' +
        generator.destinationRoot() +
        '. ' +
        'The command must be run in a LoopBack project.',
    );
    generator.exit(err);
    return;
  }

  const projectDeps = pkg.dependencies || {};
  const projectDevDeps = pkg.devDependencies || {};

  const dependentPackage = '@loopback/core';
  const projectDepsNames = Object.keys(projectDeps);

  if (!projectDepsNames.includes(dependentPackage)) {
    const err = new Error(
      'No `@loopback/core` package found in the "dependencies" section of ' +
        generator.destinationPath('package.json') +
        '. ' +
        'The command must be run in a LoopBack project.',
    );
    generator.exit(err);
    return;
  }

  const incompatibleDeps: Record<string, [string, string]> = {};

  for (const d in templateDeps) {
    const versionRange: string = projectDeps[d] || projectDevDeps[d];
    if (!versionRange) continue;
    // https://github.com/strongloop/loopback-next/issues/2028
    // https://github.com/npm/node-semver/pull/238
    // semver.intersects does not like `*`, `x`, or `X`
    if (versionRange.match(/^\*|x|X/)) continue;
    if (generator.options.semver === false) {
      // For `lb4 update` command, check exact matches
      if (versionRange !== templateDeps[d]) {
        incompatibleDeps[d] = [versionRange, templateDeps[d]];
      }
      continue;
    }
    if (semver.intersects(versionRange, templateDeps[d])) continue;
    incompatibleDeps[d] = [versionRange, templateDeps[d]];
  }
  if (Object.keys(incompatibleDeps).length === 0) {
    // No incompatible dependencies
    if (generator.command === 'update') {
      generator.log(
        chalk.green(
          `The project dependencies are compatible with @loopback/cli@${cliPkg.version}`,
        ),
      );
    }
    return;
  }

  const originalCliVersion = generator.config.get('update') || '<unknown>';
  generator.log(
    chalk.red(
      `The project was originally generated by @loopback/cli@${originalCliVersion}.`,
    ),
  );

  generator.log(
    chalk.red(
      `The following dependencies are incompatible with @loopback/cli@${cliPkg.version}:`,
    ),
  );
  for (const d in incompatibleDeps) {
    const deps = incompatibleDeps[d];
    const msg = format(chalk.yellow('- %s: %s (cli %s)'), d, ...deps);
    generator.log(msg);
  }
  return incompatibleDeps;
}

/**
 * Update project dependencies with module versions from the cli template
 * @param pkg - Package json object for the project
 * @param generator - Yeoman generator instance
 */
export function updateDependencies(generator: LoopBackGenerator) {
  const pkg =
    generator.packageJson ??
    generator.fs.readJSON(generator.destinationPath('package.json'));
  const depUpdates = [];
  for (const d in templateDeps) {
    if (
      pkg.dependencies &&
      pkg.dependencies[d] &&
      pkg.dependencies[d] !== templateDeps[d]
    ) {
      depUpdates.push(
        `- Dependency ${d}: ${pkg.dependencies[d]} => ${templateDeps[d]}`,
      );
      pkg.dependencies[d] = templateDeps[d];
    }
    if (
      pkg.devDependencies &&
      pkg.devDependencies[d] &&
      pkg.devDependencies[d] !== templateDeps[d]
    ) {
      depUpdates.push(
        `- DevDependency ${d}: ${pkg.devDependencies[d]} => ${templateDeps[d]}`,
      );
      pkg.devDependencies[d] = templateDeps[d];
    }
  }
  if (depUpdates.length) {
    depUpdates.sort().forEach(d => generator.log(d));
  }
  generator.log(
    chalk.red('Upgrading dependencies may break the current project.'),
  );
  generator.fs.writeJSON(generator.destinationPath('package.json'), pkg);
  generator.npmInstall();
}

/**
 * Check the LoopBack project dependencies and versions
 * @param generator - Yeoman generator instance
 */
export async function checkLoopBackProject(generator: LoopBackGenerator) {
  if (generator.shouldExit()) return false;

  const incompatibleDeps = await checkDependencies(generator);
  if (incompatibleDeps == null) return;
  if (Object.keys(incompatibleDeps).length === 0) return;

  const choices = [
    {
      name: 'Upgrade project dependencies',
      value: 'upgrade',
    },
    {
      name: 'Skip upgrading project dependencies',
      value: 'continue',
    },
  ];
  if (generator.command !== 'update') {
    choices.unshift({
      name: 'Abort now',
      value: 'abort',
    });
  }
  const prompts = [
    {
      name: 'decision',
      message: `How do you want to proceed?`,
      type: 'list',
      choices,
      default: 0,
    },
  ];
  const answers = await generator.prompt(prompts);
  if (answers && answers.decision === 'continue') {
    return;
  }
  if (answers && answers.decision === 'upgrade') {
    updateDependencies(generator);
    return;
  }
  generator.exit(new Error('Incompatible dependencies'));
}

/**
 * Check if the current cli is out of date
 * @param log - Log function
 */
export async function checkCliVersion(log = console.log) {
  const latestCliVersion = await latestVersion('@loopback/cli');
  if (latestCliVersion !== cliPkg.version) {
    const current = chalk.grey(cliPkg.version);
    const latest = chalk.green(latestCliVersion);
    const cmd = chalk.cyan(`npm i -g ${cliPkg.name}`);
    const message = `
Update available ${current} ${chalk.reset(' â†’ ')} ${latest}
Run ${cmd} to update.`;
    log(message);
  } else {
    log(chalk.green(`${cliPkg.name}@${cliPkg.version} is up to date.`));
  }
}


/**
 * Check package.json and dependencies.json to find out versions for generated
 * dependencies
 */
export function getDependencies() {
  const pkg = cliPkg;
  let version = pkg.version;
  // First look for config.loopbackVersion
  if (pkg.config && pkg.config.loopbackVersion) {
    version = pkg.config.loopbackVersion;
  }
  // Set it to be `^x.y.0`
  const loopbackVersion =
    '^' + semver.major(version) + '.' + semver.minor(version) + '.0';

  const deps: Record<string, string> = {};
  const dependencies = (pkg.config && pkg.config.templateDependencies) || {};
  for (const i in dependencies) {
    // Default to loopback version if the version for a given dependency is ""
    deps[i] = dependencies[i] || loopbackVersion;
  }
  return deps;
}
